import { Location } from '@angular/common';
import { ComponentFactoryResolver, ComponentRef, ElementRef, EventEmitter, NgZone, OnDestroy, OnInit, ViewContainerRef } from '@angular/core';
import { ActivatedRoute, ChildrenOutletContexts, OutletContext, Router } from '@angular/router';
import { Config } from '../../providers/config';
import { NavController } from '../../providers/nav-controller';
import { RouteView } from './stack-utils';
import * as ɵngcc0 from '@angular/core';
export declare class IonRouterOutlet implements OnDestroy, OnInit {
    private parentContexts;
    private location;
    private resolver;
    private config;
    private navCtrl;
    readonly parentOutlet?: IonRouterOutlet;
    nativeEl: HTMLIonRouterOutletElement;
    private activated;
    private activatedView;
    private _activatedRoute;
    private _swipeGesture?;
    private name;
    private stackCtrl;
    private proxyMap;
    private currentActivatedRoute$;
    tabsPrefix: string | undefined;
    stackEvents: EventEmitter<any>;
    activateEvents: EventEmitter<any>;
    deactivateEvents: EventEmitter<any>;
    animated: boolean;
    swipeGesture: boolean;
    constructor(parentContexts: ChildrenOutletContexts, location: ViewContainerRef, resolver: ComponentFactoryResolver, name: string, tabs: string, config: Config, navCtrl: NavController, commonLocation: Location, elementRef: ElementRef, router: Router, zone: NgZone, activatedRoute: ActivatedRoute, parentOutlet?: IonRouterOutlet);
    ngOnDestroy(): void;
    getContext(): OutletContext | null;
    ngOnInit(): void;
    readonly isActivated: boolean;
    readonly component: object;
    readonly activatedRoute: ActivatedRoute;
    readonly activatedRouteData: any;
    /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     */
    detach(): ComponentRef<any>;
    /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     */
    attach(_ref: ComponentRef<any>, _activatedRoute: ActivatedRoute): void;
    deactivate(): void;
    activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver | null): void;
    /**
     * Returns `true` if there are pages in the stack to go back.
     */
    canGoBack(deep?: number, stackId?: string): boolean;
    /**
     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.
     */
    pop(deep?: number, stackId?: string): Promise<boolean>;
    /**
     * Returns the URL of the active page of each stack.
     */
    getLastUrl(stackId?: string): string | undefined;
    /**
     * Returns the RouteView of the active page of each stack.
     * @internal
     */
    getLastRouteView(stackId?: string): RouteView | undefined;
    /**
     * Returns the root view in the tab stack.
     * @internal
     */
    getRootView(stackId?: string): RouteView | undefined;
    /**
     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.
     */
    getActiveStackId(): string | undefined;
    /**
     * Since the activated route can change over the life time of a component in an ion router outlet, we create
     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.
     */
    private createActivatedRouteProxy;
    /**
     * Create a wrapped observable that will switch to the latest activated route matched by the given component
     */
    private proxyObservable;
    /**
     * Updates the activated route proxy for the given component to the new incoming router state
     */
    private updateActivatedRouteProxy;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IonRouterOutlet>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IonRouterOutlet, "ion-router-outlet", ["outlet"], {
    "animated": "animated";
    "swipeGesture": "swipeGesture";
}, {
    "stackEvents": "stackEvents";
    "activateEvents": "activate";
    "deactivateEvents": "deactivate";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW9uLXJvdXRlci1vdXRsZXQuZC50cyIsInNvdXJjZXMiOlsiaW9uLXJvdXRlci1vdXRsZXQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0VBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9jYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRSZWYsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lLCBPbkRlc3Ryb3ksIE9uSW5pdCwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWN0aXZhdGVkUm91dGUsIENoaWxkcmVuT3V0bGV0Q29udGV4dHMsIE91dGxldENvbnRleHQsIFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBDb25maWcgfSBmcm9tICcuLi8uLi9wcm92aWRlcnMvY29uZmlnJztcbmltcG9ydCB7IE5hdkNvbnRyb2xsZXIgfSBmcm9tICcuLi8uLi9wcm92aWRlcnMvbmF2LWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgUm91dGVWaWV3IH0gZnJvbSAnLi9zdGFjay11dGlscyc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBJb25Sb3V0ZXJPdXRsZXQgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gICAgcHJpdmF0ZSBwYXJlbnRDb250ZXh0cztcbiAgICBwcml2YXRlIGxvY2F0aW9uO1xuICAgIHByaXZhdGUgcmVzb2x2ZXI7XG4gICAgcHJpdmF0ZSBjb25maWc7XG4gICAgcHJpdmF0ZSBuYXZDdHJsO1xuICAgIHJlYWRvbmx5IHBhcmVudE91dGxldD86IElvblJvdXRlck91dGxldDtcbiAgICBuYXRpdmVFbDogSFRNTElvblJvdXRlck91dGxldEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBhY3RpdmF0ZWQ7XG4gICAgcHJpdmF0ZSBhY3RpdmF0ZWRWaWV3O1xuICAgIHByaXZhdGUgX2FjdGl2YXRlZFJvdXRlO1xuICAgIHByaXZhdGUgX3N3aXBlR2VzdHVyZT87XG4gICAgcHJpdmF0ZSBuYW1lO1xuICAgIHByaXZhdGUgc3RhY2tDdHJsO1xuICAgIHByaXZhdGUgcHJveHlNYXA7XG4gICAgcHJpdmF0ZSBjdXJyZW50QWN0aXZhdGVkUm91dGUkO1xuICAgIHRhYnNQcmVmaXg6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBzdGFja0V2ZW50czogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgYWN0aXZhdGVFdmVudHM6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIGRlYWN0aXZhdGVFdmVudHM6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIGFuaW1hdGVkOiBib29sZWFuO1xuICAgIHN3aXBlR2VzdHVyZTogYm9vbGVhbjtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRDb250ZXh0czogQ2hpbGRyZW5PdXRsZXRDb250ZXh0cywgbG9jYXRpb246IFZpZXdDb250YWluZXJSZWYsIHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIG5hbWU6IHN0cmluZywgdGFiczogc3RyaW5nLCBjb25maWc6IENvbmZpZywgbmF2Q3RybDogTmF2Q29udHJvbGxlciwgY29tbW9uTG9jYXRpb246IExvY2F0aW9uLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCByb3V0ZXI6IFJvdXRlciwgem9uZTogTmdab25lLCBhY3RpdmF0ZWRSb3V0ZTogQWN0aXZhdGVkUm91dGUsIHBhcmVudE91dGxldD86IElvblJvdXRlck91dGxldCk7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICBnZXRDb250ZXh0KCk6IE91dGxldENvbnRleHQgfCBudWxsO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgcmVhZG9ubHkgaXNBY3RpdmF0ZWQ6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgY29tcG9uZW50OiBvYmplY3Q7XG4gICAgcmVhZG9ubHkgYWN0aXZhdGVkUm91dGU6IEFjdGl2YXRlZFJvdXRlO1xuICAgIHJlYWRvbmx5IGFjdGl2YXRlZFJvdXRlRGF0YTogYW55O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBgUm91dGVSZXVzZVN0cmF0ZWd5YCBpbnN0cnVjdHMgdG8gZGV0YWNoIHRoZSBzdWJ0cmVlXG4gICAgICovXG4gICAgZGV0YWNoKCk6IENvbXBvbmVudFJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBgUm91dGVSZXVzZVN0cmF0ZWd5YCBpbnN0cnVjdHMgdG8gcmUtYXR0YWNoIGEgcHJldmlvdXNseSBkZXRhY2hlZCBzdWJ0cmVlXG4gICAgICovXG4gICAgYXR0YWNoKF9yZWY6IENvbXBvbmVudFJlZjxhbnk+LCBfYWN0aXZhdGVkUm91dGU6IEFjdGl2YXRlZFJvdXRlKTogdm9pZDtcbiAgICBkZWFjdGl2YXRlKCk6IHZvaWQ7XG4gICAgYWN0aXZhdGVXaXRoKGFjdGl2YXRlZFJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSwgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB8IG51bGwpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGFyZSBwYWdlcyBpbiB0aGUgc3RhY2sgdG8gZ28gYmFjay5cbiAgICAgKi9cbiAgICBjYW5Hb0JhY2soZGVlcD86IG51bWJlciwgc3RhY2tJZD86IHN0cmluZyk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdG8gYHRydWVgIGlmIGl0IHRoZSBvdXRsZXQgd2FzIGFibGUgdG8gc3VjZXNzZnVsbHkgcG9wIHRoZSBsYXN0IE4gcGFnZXMuXG4gICAgICovXG4gICAgcG9wKGRlZXA/OiBudW1iZXIsIHN0YWNrSWQ/OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFVSTCBvZiB0aGUgYWN0aXZlIHBhZ2Ugb2YgZWFjaCBzdGFjay5cbiAgICAgKi9cbiAgICBnZXRMYXN0VXJsKHN0YWNrSWQ/OiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgUm91dGVWaWV3IG9mIHRoZSBhY3RpdmUgcGFnZSBvZiBlYWNoIHN0YWNrLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldExhc3RSb3V0ZVZpZXcoc3RhY2tJZD86IHN0cmluZyk6IFJvdXRlVmlldyB8IHVuZGVmaW5lZDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByb290IHZpZXcgaW4gdGhlIHRhYiBzdGFjay5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRSb290VmlldyhzdGFja0lkPzogc3RyaW5nKTogUm91dGVWaWV3IHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFjdGl2ZSBzdGFjayBJRC4gSW4gdGhlIGNvbnRleHQgb2YgaW9uLXRhYnMsIGl0IG1lYW5zIHRoZSBhY3RpdmUgdGFiLlxuICAgICAqL1xuICAgIGdldEFjdGl2ZVN0YWNrSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFNpbmNlIHRoZSBhY3RpdmF0ZWQgcm91dGUgY2FuIGNoYW5nZSBvdmVyIHRoZSBsaWZlIHRpbWUgb2YgYSBjb21wb25lbnQgaW4gYW4gaW9uIHJvdXRlciBvdXRsZXQsIHdlIGNyZWF0ZVxuICAgICAqIGEgcHJveHkgc28gdGhhdCB3ZSBjYW4gdXBkYXRlIHRoZSB2YWx1ZXMgb3ZlciB0aW1lIGFzIGEgdXNlciBuYXZpZ2F0ZXMgYmFjayB0byBjb21wb25lbnRzIGFscmVhZHkgaW4gdGhlIHN0YWNrLlxuICAgICAqL1xuICAgIHByaXZhdGUgY3JlYXRlQWN0aXZhdGVkUm91dGVQcm94eTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB3cmFwcGVkIG9ic2VydmFibGUgdGhhdCB3aWxsIHN3aXRjaCB0byB0aGUgbGF0ZXN0IGFjdGl2YXRlZCByb3V0ZSBtYXRjaGVkIGJ5IHRoZSBnaXZlbiBjb21wb25lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIHByb3h5T2JzZXJ2YWJsZTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBhY3RpdmF0ZWQgcm91dGUgcHJveHkgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQgdG8gdGhlIG5ldyBpbmNvbWluZyByb3V0ZXIgc3RhdGVcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUFjdGl2YXRlZFJvdXRlUHJveHk7XG59XG4iXX0=