import { ElementRef, IterableDiffers, NgZone, SimpleChanges, TrackByFunction } from '@angular/core';
import { FooterHeightFn, HeaderFn, HeaderHeightFn, ItemHeightFn } from '@ionic/core';
import { VirtualFooter } from './virtual-footer';
import { VirtualHeader } from './virtual-header';
import { VirtualItem } from './virtual-item';
import * as ɵngcc0 from '@angular/core';
export declare interface IonVirtualScroll {
    /**
     * It is important to provide this
     * if virtual item height will be significantly larger than the default
     * The approximate height of each virtual item template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This height value can only use `px` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions before the item has been rendered.
     */
    approxItemHeight: number;
    /**
     * The approximate height of each header template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This height value can only use `px` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions before the item has been rendered.
     */
    approxHeaderHeight: number;
    /**
     * The approximate width of each footer template's cell.
     * This dimension is used to help determine how many cells should
     * be created when initialized, and to help calculate the height of
     * the scrollable area. This height value can only use `px` units.
     * Note that the actual rendered size of each cell comes from the
     * app's CSS, whereas this approximation is used to help calculate
     * initial dimensions before the item has been rendered.
     */
    approxFooterHeight: number;
    /**
     * Section headers and the data used within its given
     * template can be dynamically created by passing a function to `headerFn`.
     * For example, a large list of contacts usually has dividers between each
     * letter in the alphabet. App's can provide their own custom `headerFn`
     * which is called with each record within the dataset. The logic within
     * the header function can decide if the header template should be used,
     * and what data to give to the header template. The function must return
     * `null` if a header cell shouldn't be created.
     */
    headerFn?: HeaderFn;
    /**
     * Section footers and the data used within its given
     * template can be dynamically created by passing a function to `footerFn`.
     * The logic within the footer function can decide if the footer template
     * should be used, and what data to give to the footer template. The function
     * must return `null` if a footer cell shouldn't be created.
     */
    footerFn?: HeaderFn;
    /**
     * The data that builds the templates within the virtual scroll.
     * It's important to note that when this data has changed, then the
     * entire virtual scroll is reset, which is an expensive operation and
     * should be avoided if possible.
     */
    items?: any[];
    /**
     * An optional function that maps each item within their height.
     * When this function is provided, heavy optimizations and fast path can be taked by
     * `ion-virtual-scroll` leading to massive performance improvements.
     *
     * This function allows to skip all DOM reads, which can be Doing so leads
     * to massive performance
     */
    itemHeight?: ItemHeightFn;
    /**
     * An optional function that maps each item header within their height.
     */
    headerHeight?: HeaderHeightFn;
    /**
     * An optional function that maps each item footer within their height.
     */
    footerHeight?: FooterHeightFn;
    /**
     * Same as `ngForTrackBy` which can be used on `ngFor`.
     */
    trackBy: TrackByFunction<any>;
    /**
     * This method marks the tail the items array as dirty, so they can be re-rendered.  It's equivalent to calling:  ```js    * virtualScroll.checkRange(lastItemLen, items.length - lastItemLen);    * ```
     */
    'checkEnd': () => void;
    /**
     * This method marks a subset of items as dirty, so they can be re-rendered. Items should be marked as dirty any time the content or their style changes.  The subset of items to be updated can are specifing by an offset and a length.
     */
    'checkRange': (offset: number, len?: number) => void;
    /**
     * Returns the position of the virtual item at the given index.
     */
    'positionForItem': (index: number) => Promise<number>;
}
export declare class IonVirtualScroll {
    private z;
    private iterableDiffers;
    private differ?;
    private el;
    private refMap;
    itmTmp: VirtualItem;
    hdrTmp: VirtualHeader;
    ftrTmp: VirtualFooter;
    constructor(z: NgZone, iterableDiffers: IterableDiffers, elementRef: ElementRef);
    ngOnChanges(changes: SimpleChanges): void;
    ngDoCheck(): void;
    private nodeRender;
    private getComponent;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IonVirtualScroll>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<IonVirtualScroll, "ion-virtual-scroll", never, {
    "approxItemHeight": "approxItemHeight";
    "approxHeaderHeight": "approxHeaderHeight";
    "approxFooterHeight": "approxFooterHeight";
    "headerFn": "headerFn";
    "footerFn": "footerFn";
    "items": "items";
    "itemHeight": "itemHeight";
    "headerHeight": "headerHeight";
    "footerHeight": "footerHeight";
    "trackBy": "trackBy";
}, {}, ["itmTmp", "hdrTmp", "ftrTmp"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlydHVhbC1zY3JvbGwuZC50cyIsInNvdXJjZXMiOlsidmlydHVhbC1zY3JvbGwuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJHQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEl0ZXJhYmxlRGlmZmVycywgTmdab25lLCBTaW1wbGVDaGFuZ2VzLCBUcmFja0J5RnVuY3Rpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvb3RlckhlaWdodEZuLCBIZWFkZXJGbiwgSGVhZGVySGVpZ2h0Rm4sIEl0ZW1IZWlnaHRGbiB9IGZyb20gJ0Bpb25pYy9jb3JlJztcbmltcG9ydCB7IFZpcnR1YWxGb290ZXIgfSBmcm9tICcuL3ZpcnR1YWwtZm9vdGVyJztcbmltcG9ydCB7IFZpcnR1YWxIZWFkZXIgfSBmcm9tICcuL3ZpcnR1YWwtaGVhZGVyJztcbmltcG9ydCB7IFZpcnR1YWxJdGVtIH0gZnJvbSAnLi92aXJ0dWFsLWl0ZW0nO1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIElvblZpcnR1YWxTY3JvbGwge1xuICAgIC8qKlxuICAgICAqIEl0IGlzIGltcG9ydGFudCB0byBwcm92aWRlIHRoaXNcbiAgICAgKiBpZiB2aXJ0dWFsIGl0ZW0gaGVpZ2h0IHdpbGwgYmUgc2lnbmlmaWNhbnRseSBsYXJnZXIgdGhhbiB0aGUgZGVmYXVsdFxuICAgICAqIFRoZSBhcHByb3hpbWF0ZSBoZWlnaHQgb2YgZWFjaCB2aXJ0dWFsIGl0ZW0gdGVtcGxhdGUncyBjZWxsLlxuICAgICAqIFRoaXMgZGltZW5zaW9uIGlzIHVzZWQgdG8gaGVscCBkZXRlcm1pbmUgaG93IG1hbnkgY2VsbHMgc2hvdWxkXG4gICAgICogYmUgY3JlYXRlZCB3aGVuIGluaXRpYWxpemVkLCBhbmQgdG8gaGVscCBjYWxjdWxhdGUgdGhlIGhlaWdodCBvZlxuICAgICAqIHRoZSBzY3JvbGxhYmxlIGFyZWEuIFRoaXMgaGVpZ2h0IHZhbHVlIGNhbiBvbmx5IHVzZSBgcHhgIHVuaXRzLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgYWN0dWFsIHJlbmRlcmVkIHNpemUgb2YgZWFjaCBjZWxsIGNvbWVzIGZyb20gdGhlXG4gICAgICogYXBwJ3MgQ1NTLCB3aGVyZWFzIHRoaXMgYXBwcm94aW1hdGlvbiBpcyB1c2VkIHRvIGhlbHAgY2FsY3VsYXRlXG4gICAgICogaW5pdGlhbCBkaW1lbnNpb25zIGJlZm9yZSB0aGUgaXRlbSBoYXMgYmVlbiByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBhcHByb3hJdGVtSGVpZ2h0OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGFwcHJveGltYXRlIGhlaWdodCBvZiBlYWNoIGhlYWRlciB0ZW1wbGF0ZSdzIGNlbGwuXG4gICAgICogVGhpcyBkaW1lbnNpb24gaXMgdXNlZCB0byBoZWxwIGRldGVybWluZSBob3cgbWFueSBjZWxscyBzaG91bGRcbiAgICAgKiBiZSBjcmVhdGVkIHdoZW4gaW5pdGlhbGl6ZWQsIGFuZCB0byBoZWxwIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mXG4gICAgICogdGhlIHNjcm9sbGFibGUgYXJlYS4gVGhpcyBoZWlnaHQgdmFsdWUgY2FuIG9ubHkgdXNlIGBweGAgdW5pdHMuXG4gICAgICogTm90ZSB0aGF0IHRoZSBhY3R1YWwgcmVuZGVyZWQgc2l6ZSBvZiBlYWNoIGNlbGwgY29tZXMgZnJvbSB0aGVcbiAgICAgKiBhcHAncyBDU1MsIHdoZXJlYXMgdGhpcyBhcHByb3hpbWF0aW9uIGlzIHVzZWQgdG8gaGVscCBjYWxjdWxhdGVcbiAgICAgKiBpbml0aWFsIGRpbWVuc2lvbnMgYmVmb3JlIHRoZSBpdGVtIGhhcyBiZWVuIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGFwcHJveEhlYWRlckhlaWdodDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBhcHByb3hpbWF0ZSB3aWR0aCBvZiBlYWNoIGZvb3RlciB0ZW1wbGF0ZSdzIGNlbGwuXG4gICAgICogVGhpcyBkaW1lbnNpb24gaXMgdXNlZCB0byBoZWxwIGRldGVybWluZSBob3cgbWFueSBjZWxscyBzaG91bGRcbiAgICAgKiBiZSBjcmVhdGVkIHdoZW4gaW5pdGlhbGl6ZWQsIGFuZCB0byBoZWxwIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mXG4gICAgICogdGhlIHNjcm9sbGFibGUgYXJlYS4gVGhpcyBoZWlnaHQgdmFsdWUgY2FuIG9ubHkgdXNlIGBweGAgdW5pdHMuXG4gICAgICogTm90ZSB0aGF0IHRoZSBhY3R1YWwgcmVuZGVyZWQgc2l6ZSBvZiBlYWNoIGNlbGwgY29tZXMgZnJvbSB0aGVcbiAgICAgKiBhcHAncyBDU1MsIHdoZXJlYXMgdGhpcyBhcHByb3hpbWF0aW9uIGlzIHVzZWQgdG8gaGVscCBjYWxjdWxhdGVcbiAgICAgKiBpbml0aWFsIGRpbWVuc2lvbnMgYmVmb3JlIHRoZSBpdGVtIGhhcyBiZWVuIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGFwcHJveEZvb3RlckhlaWdodDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNlY3Rpb24gaGVhZGVycyBhbmQgdGhlIGRhdGEgdXNlZCB3aXRoaW4gaXRzIGdpdmVuXG4gICAgICogdGVtcGxhdGUgY2FuIGJlIGR5bmFtaWNhbGx5IGNyZWF0ZWQgYnkgcGFzc2luZyBhIGZ1bmN0aW9uIHRvIGBoZWFkZXJGbmAuXG4gICAgICogRm9yIGV4YW1wbGUsIGEgbGFyZ2UgbGlzdCBvZiBjb250YWN0cyB1c3VhbGx5IGhhcyBkaXZpZGVycyBiZXR3ZWVuIGVhY2hcbiAgICAgKiBsZXR0ZXIgaW4gdGhlIGFscGhhYmV0LiBBcHAncyBjYW4gcHJvdmlkZSB0aGVpciBvd24gY3VzdG9tIGBoZWFkZXJGbmBcbiAgICAgKiB3aGljaCBpcyBjYWxsZWQgd2l0aCBlYWNoIHJlY29yZCB3aXRoaW4gdGhlIGRhdGFzZXQuIFRoZSBsb2dpYyB3aXRoaW5cbiAgICAgKiB0aGUgaGVhZGVyIGZ1bmN0aW9uIGNhbiBkZWNpZGUgaWYgdGhlIGhlYWRlciB0ZW1wbGF0ZSBzaG91bGQgYmUgdXNlZCxcbiAgICAgKiBhbmQgd2hhdCBkYXRhIHRvIGdpdmUgdG8gdGhlIGhlYWRlciB0ZW1wbGF0ZS4gVGhlIGZ1bmN0aW9uIG11c3QgcmV0dXJuXG4gICAgICogYG51bGxgIGlmIGEgaGVhZGVyIGNlbGwgc2hvdWxkbid0IGJlIGNyZWF0ZWQuXG4gICAgICovXG4gICAgaGVhZGVyRm4/OiBIZWFkZXJGbjtcbiAgICAvKipcbiAgICAgKiBTZWN0aW9uIGZvb3RlcnMgYW5kIHRoZSBkYXRhIHVzZWQgd2l0aGluIGl0cyBnaXZlblxuICAgICAqIHRlbXBsYXRlIGNhbiBiZSBkeW5hbWljYWxseSBjcmVhdGVkIGJ5IHBhc3NpbmcgYSBmdW5jdGlvbiB0byBgZm9vdGVyRm5gLlxuICAgICAqIFRoZSBsb2dpYyB3aXRoaW4gdGhlIGZvb3RlciBmdW5jdGlvbiBjYW4gZGVjaWRlIGlmIHRoZSBmb290ZXIgdGVtcGxhdGVcbiAgICAgKiBzaG91bGQgYmUgdXNlZCwgYW5kIHdoYXQgZGF0YSB0byBnaXZlIHRvIHRoZSBmb290ZXIgdGVtcGxhdGUuIFRoZSBmdW5jdGlvblxuICAgICAqIG11c3QgcmV0dXJuIGBudWxsYCBpZiBhIGZvb3RlciBjZWxsIHNob3VsZG4ndCBiZSBjcmVhdGVkLlxuICAgICAqL1xuICAgIGZvb3RlckZuPzogSGVhZGVyRm47XG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgdGhhdCBidWlsZHMgdGhlIHRlbXBsYXRlcyB3aXRoaW4gdGhlIHZpcnR1YWwgc2Nyb2xsLlxuICAgICAqIEl0J3MgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB3aGVuIHRoaXMgZGF0YSBoYXMgY2hhbmdlZCwgdGhlbiB0aGVcbiAgICAgKiBlbnRpcmUgdmlydHVhbCBzY3JvbGwgaXMgcmVzZXQsIHdoaWNoIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24gYW5kXG4gICAgICogc2hvdWxkIGJlIGF2b2lkZWQgaWYgcG9zc2libGUuXG4gICAgICovXG4gICAgaXRlbXM/OiBhbnlbXTtcbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IG1hcHMgZWFjaCBpdGVtIHdpdGhpbiB0aGVpciBoZWlnaHQuXG4gICAgICogV2hlbiB0aGlzIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBoZWF2eSBvcHRpbWl6YXRpb25zIGFuZCBmYXN0IHBhdGggY2FuIGJlIHRha2VkIGJ5XG4gICAgICogYGlvbi12aXJ0dWFsLXNjcm9sbGAgbGVhZGluZyB0byBtYXNzaXZlIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHRvIHNraXAgYWxsIERPTSByZWFkcywgd2hpY2ggY2FuIGJlIERvaW5nIHNvIGxlYWRzXG4gICAgICogdG8gbWFzc2l2ZSBwZXJmb3JtYW5jZVxuICAgICAqL1xuICAgIGl0ZW1IZWlnaHQ/OiBJdGVtSGVpZ2h0Rm47XG4gICAgLyoqXG4gICAgICogQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCBtYXBzIGVhY2ggaXRlbSBoZWFkZXIgd2l0aGluIHRoZWlyIGhlaWdodC5cbiAgICAgKi9cbiAgICBoZWFkZXJIZWlnaHQ/OiBIZWFkZXJIZWlnaHRGbjtcbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IG1hcHMgZWFjaCBpdGVtIGZvb3RlciB3aXRoaW4gdGhlaXIgaGVpZ2h0LlxuICAgICAqL1xuICAgIGZvb3RlckhlaWdodD86IEZvb3RlckhlaWdodEZuO1xuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgYG5nRm9yVHJhY2tCeWAgd2hpY2ggY2FuIGJlIHVzZWQgb24gYG5nRm9yYC5cbiAgICAgKi9cbiAgICB0cmFja0J5OiBUcmFja0J5RnVuY3Rpb248YW55PjtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXJrcyB0aGUgdGFpbCB0aGUgaXRlbXMgYXJyYXkgYXMgZGlydHksIHNvIHRoZXkgY2FuIGJlIHJlLXJlbmRlcmVkLiAgSXQncyBlcXVpdmFsZW50IHRvIGNhbGxpbmc6ICBgYGBqcyAgICAqIHZpcnR1YWxTY3JvbGwuY2hlY2tSYW5nZShsYXN0SXRlbUxlbiwgaXRlbXMubGVuZ3RoIC0gbGFzdEl0ZW1MZW4pOyAgICAqIGBgYFxuICAgICAqL1xuICAgICdjaGVja0VuZCc6ICgpID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgbWFya3MgYSBzdWJzZXQgb2YgaXRlbXMgYXMgZGlydHksIHNvIHRoZXkgY2FuIGJlIHJlLXJlbmRlcmVkLiBJdGVtcyBzaG91bGQgYmUgbWFya2VkIGFzIGRpcnR5IGFueSB0aW1lIHRoZSBjb250ZW50IG9yIHRoZWlyIHN0eWxlIGNoYW5nZXMuICBUaGUgc3Vic2V0IG9mIGl0ZW1zIHRvIGJlIHVwZGF0ZWQgY2FuIGFyZSBzcGVjaWZpbmcgYnkgYW4gb2Zmc2V0IGFuZCBhIGxlbmd0aC5cbiAgICAgKi9cbiAgICAnY2hlY2tSYW5nZSc6IChvZmZzZXQ6IG51bWJlciwgbGVuPzogbnVtYmVyKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aXJ0dWFsIGl0ZW0gYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgICdwb3NpdGlvbkZvckl0ZW0nOiAoaW5kZXg6IG51bWJlcikgPT4gUHJvbWlzZTxudW1iZXI+O1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSW9uVmlydHVhbFNjcm9sbCB7XG4gICAgcHJpdmF0ZSB6O1xuICAgIHByaXZhdGUgaXRlcmFibGVEaWZmZXJzO1xuICAgIHByaXZhdGUgZGlmZmVyPztcbiAgICBwcml2YXRlIGVsO1xuICAgIHByaXZhdGUgcmVmTWFwO1xuICAgIGl0bVRtcDogVmlydHVhbEl0ZW07XG4gICAgaGRyVG1wOiBWaXJ0dWFsSGVhZGVyO1xuICAgIGZ0clRtcDogVmlydHVhbEZvb3RlcjtcbiAgICBjb25zdHJ1Y3Rvcih6OiBOZ1pvbmUsIGl0ZXJhYmxlRGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmKTtcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcbiAgICBuZ0RvQ2hlY2soKTogdm9pZDtcbiAgICBwcml2YXRlIG5vZGVSZW5kZXI7XG4gICAgcHJpdmF0ZSBnZXRDb21wb25lbnQ7XG59XG4iXX0=